function [featureTable,outputTable] = diagnosticFeatures(inputData)
%DIAGNOSTICFEATURES recreates results in Diagnostic Feature Designer.
%
% Input:
%  inputData: A table or a cell array of tables/matrices containing the
%  data as those imported into the app.
%
% Output:
%  featureTable: A table containing all features and condition variables.
%  outputTable: A table containing the computation results.
%
% This function computes spectra:
%  flow_ps/SpectrumData
%  pressure_ps/SpectrumData
%
% This function computes features:
%  flow_sigstats/ClearanceFactor
%  flow_sigstats/CrestFactor
%  flow_sigstats/ImpulseFactor
%  flow_sigstats/Mean
%  flow_sigstats/RMS
%  flow_sigstats/THD
%  pressure_sigstats/ClearanceFactor
%  pressure_sigstats/CrestFactor
%  pressure_sigstats/ImpulseFactor
%  pressure_sigstats/Mean
%  pressure_sigstats/RMS
%  pressure_sigstats/THD
%  flow_ps_spec/PeakAmp1
%  flow_ps_spec/PeakAmp2
%  flow_ps_spec/PeakAmp3
%  flow_ps_spec/PeakFreq1
%  pressure_ps_spec/PeakAmp1
%  pressure_ps_spec/PeakAmp2
%  pressure_ps_spec/PeakAmp3
%  pressure_ps_spec/PeakFreq1
%
% Organization of the function:
% 1. Compute signals/spectra/features
% 2. Extract computed features into a table
%
% Modify the function to add or remove data processing, feature generation
% or ranking operations.

% Auto-generated by MATLAB on 21-Jul-2022 16:07:21

% Create output ensemble.
outputEnsemble = workspaceEnsemble(inputData,'DataVariables',["flow";"pressure"],'ConditionVariables',"faultCode");

% Reset the ensemble to read from the beginning of the ensemble.
reset(outputEnsemble);

% Append new signal or feature names to DataVariables.
outputEnsemble.DataVariables = unique([outputEnsemble.DataVariables;"flow_sigstats";"pressure_sigstats";"flow_ps";"pressure_ps";"flow_ps_spec";"pressure_ps_spec"],'stable');

% Set SelectedVariables to select variables to read from the ensemble.
outputEnsemble.SelectedVariables = ["flow","pressure"];

% Loop through all ensemble members to read and write data.
while hasdata(outputEnsemble)
    % Read one member.
    member = read(outputEnsemble);

    % Get all input variables.
    flow = readMemberData(member,"flow",["Time","Data"]);
    pressure = readMemberData(member,"pressure",["Time","Data"]);

    % Initialize a table to store results.
    memberResult = table;

    %% SignalFeatures
    try
        % Compute signal features.
        inputSignal = flow.Data;
        ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
        CrestFactor = peak2rms(inputSignal);
        ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
        Mean = mean(inputSignal,'omitnan');
        RMS = rms(inputSignal,'omitnan');
        THD = thd(inputSignal);

        % Concatenate signal features.
        featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Mean,RMS,THD];

        % Package computed features into a table.
        featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Mean","RMS","THD"];
        flow_sigstats = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,6);
        featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Mean","RMS","THD"];
        flow_sigstats = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({flow_sigstats},'VariableNames',"flow_sigstats")]; %#ok<AGROW>

    %% SignalFeatures
    try
        % Compute signal features.
        inputSignal = pressure.Data;
        ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
        CrestFactor = peak2rms(inputSignal);
        ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
        Mean = mean(inputSignal,'omitnan');
        RMS = rms(inputSignal,'omitnan');
        THD = thd(inputSignal);

        % Concatenate signal features.
        featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Mean,RMS,THD];

        % Package computed features into a table.
        featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Mean","RMS","THD"];
        pressure_sigstats = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,6);
        featureNames = ["ClearanceFactor","CrestFactor","ImpulseFactor","Mean","RMS","THD"];
        pressure_sigstats = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({pressure_sigstats},'VariableNames',"pressure_sigstats")]; %#ok<AGROW>

    %% PowerSpectrum
    try
        % Get units to use in computed spectrum.
        tuReal = "seconds";
        tuTime = tuReal;

        % Compute effective sampling rate.
        tNumeric = time2num(flow.Time,tuReal);
        [Fs,irregular] = effectivefs(tNumeric);
        Ts = 1/Fs;

        % Resample non-uniform signals.
        x = flow.Data;
        if irregular
            x = resample(x,tNumeric,Fs,'linear');
        end

        % Compute the autoregressive model.
        data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
        arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
        model = ar(data,20,arOpt);

        % Compute the power spectrum.
        [ps,w] = spectrum(model);
        ps = reshape(ps, numel(ps), 1);

        % Convert frequency unit.
        factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
        w = factor*w;
        Fs = 2*pi*factor*Fs;

        % Remove frequencies above Nyquist frequency.
        I = w<=(Fs/2+1e4*eps);
        w = w(I);
        ps = ps(I);

        % Configure the computed spectrum.
        ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
        ps.Properties.VariableUnits = ["Hz", ""];
        ps = addprop(ps, {'SampleFrequency'}, {'table'});
        ps.Properties.CustomProperties.SampleFrequency = Fs;
        flow_ps = ps;
    catch
        flow_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({flow_ps},'VariableNames',"flow_ps")]; %#ok<AGROW>

    %% PowerSpectrum
    try
        % Get units to use in computed spectrum.
        tuReal = "seconds";
        tuTime = tuReal;

        % Compute effective sampling rate.
        tNumeric = time2num(pressure.Time,tuReal);
        [Fs,irregular] = effectivefs(tNumeric);
        Ts = 1/Fs;

        % Resample non-uniform signals.
        x = pressure.Data;
        if irregular
            x = resample(x,tNumeric,Fs,'linear');
        end

        % Compute the autoregressive model.
        data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
        arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
        model = ar(data,20,arOpt);

        % Compute the power spectrum.
        [ps,w] = spectrum(model);
        ps = reshape(ps, numel(ps), 1);

        % Convert frequency unit.
        factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
        w = factor*w;
        Fs = 2*pi*factor*Fs;

        % Remove frequencies above Nyquist frequency.
        I = w<=(Fs/2+1e4*eps);
        w = w(I);
        ps = ps(I);

        % Configure the computed spectrum.
        ps = table(w, ps, 'VariableNames', ["Frequency", "SpectrumData"]);
        ps.Properties.VariableUnits = ["Hz", ""];
        ps = addprop(ps, {'SampleFrequency'}, {'table'});
        ps.Properties.CustomProperties.SampleFrequency = Fs;
        pressure_ps = ps;
    catch
        pressure_ps = table(NaN, NaN, 'VariableNames', ["Frequency", "SpectrumData"]);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({pressure_ps},'VariableNames',"pressure_ps")]; %#ok<AGROW>

    %% SpectrumFeatures
    try
        % Compute spectral features.
        % Get frequency unit conversion factor.
        factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
        ps = flow_ps.SpectrumData;
        w = flow_ps.Frequency;
        w = factor*w;
        Fs = factor*flow_ps.Properties.CustomProperties.SampleFrequency/(2*pi);
        Ts = 1/Fs;
        mask_1 = (w>=factor*23) & (w<=factor*250);
        ps = ps(mask_1);
        w = w(mask_1);

        % Compute spectral peaks.
        [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
            'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',5);
        peakAmp = [peakAmp(:); NaN(5-numel(peakAmp),1)];
        peakFreq = [peakFreq(:); NaN(5-numel(peakFreq),1)];

        % Compute modal coefficients.
        [wn,zeta] = modalfit(ps,w/2/pi,1/Ts,5,'FitMethod','lsrf','Feedthrough',true);
        wn = 2*pi*wn/factor;
        wn = [wn(:); NaN(5-numel(wn),1)];
        zeta = [zeta(:); NaN(5-numel(zeta),1)];

        % Extract individual feature values.
        PeakAmp1 = peakAmp(1);
        PeakAmp2 = peakAmp(2);
        PeakAmp3 = peakAmp(3);
        PeakFreq1 = peakFreq(1);

        % Concatenate signal features.
        featureValues = [PeakAmp1,PeakAmp2,PeakAmp3,PeakFreq1];

        % Package computed features into a table.
        featureNames = ["PeakAmp1","PeakAmp2","PeakAmp3","PeakFreq1"];
        flow_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,4);
        featureNames = ["PeakAmp1","PeakAmp2","PeakAmp3","PeakFreq1"];
        flow_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({flow_ps_spec},'VariableNames',"flow_ps_spec")]; %#ok<AGROW>

    %% SpectrumFeatures
    try
        % Compute spectral features.
        % Get frequency unit conversion factor.
        factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
        ps = pressure_ps.SpectrumData;
        w = pressure_ps.Frequency;
        w = factor*w;
        Fs = factor*pressure_ps.Properties.CustomProperties.SampleFrequency/(2*pi);
        Ts = 1/Fs;
        mask_1 = (w>=factor*23) & (w<=factor*250);
        ps = ps(mask_1);
        w = w(mask_1);

        % Compute spectral peaks.
        [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
            'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',5);
        peakAmp = [peakAmp(:); NaN(5-numel(peakAmp),1)];
        peakFreq = [peakFreq(:); NaN(5-numel(peakFreq),1)];

        % Compute modal coefficients.
        [wn,zeta] = modalfit(ps,w/2/pi,1/Ts,5,'FitMethod','lsrf','Feedthrough',true);
        wn = 2*pi*wn/factor;
        wn = [wn(:); NaN(5-numel(wn),1)];
        zeta = [zeta(:); NaN(5-numel(zeta),1)];

        % Extract individual feature values.
        PeakAmp1 = peakAmp(1);
        PeakAmp2 = peakAmp(2);
        PeakAmp3 = peakAmp(3);
        PeakFreq1 = peakFreq(1);

        % Concatenate signal features.
        featureValues = [PeakAmp1,PeakAmp2,PeakAmp3,PeakFreq1];

        % Package computed features into a table.
        featureNames = ["PeakAmp1","PeakAmp2","PeakAmp3","PeakFreq1"];
        pressure_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    catch
        % Package computed features into a table.
        featureValues = NaN(1,4);
        featureNames = ["PeakAmp1","PeakAmp2","PeakAmp3","PeakFreq1"];
        pressure_ps_spec = array2table(featureValues,'VariableNames',featureNames);
    end

    % Append computed results to the member table.
    memberResult = [memberResult, ...
        table({pressure_ps_spec},'VariableNames',"pressure_ps_spec")]; %#ok<AGROW>

    %% Write all the results for the current member to the ensemble.
    writeToLastMemberRead(outputEnsemble,memberResult)
end

% Gather all features into a table.
featureTable = readFeatureTable(outputEnsemble);

% Set SelectedVariables to select variables to read from the ensemble.
outputEnsemble.SelectedVariables = unique([outputEnsemble.DataVariables;outputEnsemble.ConditionVariables;outputEnsemble.IndependentVariables],'stable');

% Gather results into a table.
outputTable = readall(outputEnsemble);
end
